package tools

import (
	"bytes"
	"context"
	"fmt"
	"html"
	"io"
	"net/http"
	"net/url"
	"sync"
)

// NOTE: Intended for small and simple file operations :)

type storageProviderS3 struct {
	AccessKey string // Access Key ID
	SecretKey string // Access Key Secret
	Endpoint  string // S3 Endpoint
	Region    string // S3 Region
	Bucket    string // S3 Bucket
	Host      string // To be filled from Endpoint Field
}

func (o *storageProviderS3) Start(stop context.Context, await *sync.WaitGroup) error {

	// Prepare Client
	s3url, err := url.Parse(STORAGE_S3_ENDPOINT)
	if err != nil {
		return fmt.Errorf("invalid s3 endpoint url; %s", err)
	}
	o.AccessKey = STORAGE_S3_KEY_ACCESS
	o.SecretKey = STORAGE_S3_KEY_SECRET
	o.Endpoint = STORAGE_S3_ENDPOINT
	o.Region = STORAGE_S3_REGION
	o.Bucket = STORAGE_S3_BUCKET
	o.Host = s3url.Host

	// Test Client
	ctx, cancel := NewContext()
	defer cancel()

	filename := fmt.Sprintf("_test/__%d__", GenerateSnowflake())
	filedata := "Don't worry you aren't being hacked!" +
		" This file was generated by the backend on startup to ensure it has write access to the S3 Bucket." +
		" If you're seeing this most likely the process was killed during startup." +
		" You can safely delete me :)"

	if err := o.Put(ctx, filename, "text/plain", []byte(filedata)); err != nil {
		return fmt.Errorf("missing write access; %s", err)
	}
	if r, err := o.Get(ctx, filename); err != nil {
		return fmt.Errorf("missing read access; %s", err)
	} else {
		r.Close()
	}
	if err := o.Delete(ctx, filename); err != nil {
		return fmt.Errorf("missing delete access: %s", err)
	}

	return nil
}

func (o *storageProviderS3) Put(ctx context.Context, key, contentType string, data []byte) error {

	// Generate Request
	url := fmt.Sprint("https://", o.Host, "/", key)
	req, err := http.NewRequestWithContext(ctx, http.MethodPut, url, bytes.NewReader(data))
	if err != nil {
		return err
	}
	req.Header.Add("Content-Type", contentType)
	AmazonSignRequestV4(req, data, o.AccessKey, o.SecretKey, o.Host, o.Region, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ := io.ReadAll(res.Body)
		return fmt.Errorf("put failed: %d: %s", res.StatusCode, string(body))
	}

	return nil
}

func (o *storageProviderS3) Get(ctx context.Context, key string) (io.ReadCloser, error) {

	// Generate Request
	url := fmt.Sprint("https://", o.Host, "/", key)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, http.NoBody)
	if err != nil {
		return nil, err
	}
	AmazonSignRequestV4(req, []byte{}, o.AccessKey, o.SecretKey, o.Host, o.Region, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode == 404 {
		return nil, ErrStorageFileNotFound
	}
	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ := io.ReadAll(res.Body)
		return nil, fmt.Errorf("get failed: %d: %s", res.StatusCode, string(body))
	}

	return res.Body, nil
}

func (o *storageProviderS3) Delete(ctx context.Context, keys ...string) error {

	// Generate Body
	var buffer bytes.Buffer
	buffer.WriteString("<Delete xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">")
	for _, k := range keys {
		fmt.Fprintf(&buffer, "<Object><Key>%s</Key></Object>", html.EscapeString(k))
	}
	buffer.WriteString("</Delete>")
	body := buffer.Bytes()

	// Generate Request
	url := fmt.Sprint("https://", o.Host, "/?delete")
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, &buffer)
	if err != nil {
		return err
	}
	AmazonSignRequestV4(req, body, o.AccessKey, o.SecretKey, o.Host, o.Region, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ = io.ReadAll(res.Body)
		return fmt.Errorf("server responded with status %d: %s", res.StatusCode, string(body))
	}

	return nil
}
